<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NASA Space Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            min-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #controls h2 {
            margin-bottom: 15px;
            color: #4a9eff;
            font-size: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
            font-weight: 500;
        }

        .control-group select,
        .control-group button {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }

        .control-group select {
            background: rgba(20, 30, 50, 0.95);
            color: #fff;
            border: 1px solid rgba(74, 158, 255, 0.5);
        }

        .control-group select:hover {
            background: rgba(30, 40, 60, 0.95);
            border-color: rgba(74, 158, 255, 0.7);
        }

        .control-group select:focus {
            background: rgba(30, 40, 60, 0.95);
            border-color: #4a9eff;
            outline: none;
        }

        .control-group select option {
            background: rgba(20, 30, 50, 0.98);
            color: #fff;
            padding: 8px;
        }

        .control-group button {
            background: #4a9eff;
            border: none;
            font-weight: bold;
            transition: background 0.3s;
            margin-top: 5px;
        }

        .control-group button:hover {
            background: #6bb0ff;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-container input[type="range"] {
            flex: 1;
        }

        .slider-container span {
            min-width: 50px;
            font-size: 11px;
            color: #4a9eff;
            text-align: right;
        }

        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            max-width: 350px;
        }

        #info h3 {
            color: #4a9eff;
            margin-bottom: 8px;
            font-size: 14px;
        }

        #info p {
            margin: 5px 0;
            color: #ccc;
            line-height: 1.5;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #4a9eff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #objectInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            max-width: 300px;
            display: none;
        }

        #objectInfo h3 {
            color: #4a9eff;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        #objectInfo p {
            margin: 5px 0;
            color: #ccc;
            line-height: 1.6;
        }
        
        #objectInfo strong {
            color: #4a9eff;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="loading">
            <div class="spinner"></div>
            <p>Loading Space Viewer...</p>
        </div>
        <div id="controls">
            <h2>üöÄ Space Viewer</h2>
            <div class="control-group">
                <label>Category</label>
                <select id="categorySelect">
                    <option value="planets">Planets</option>
                    <option value="dwarfPlanets">Dwarf Planets</option>
                    <option value="moons">Moons</option>
                    <option value="meteors">Meteors</option>
                    <option value="asteroids">Asteroids</option>
                    <option value="comets">Comets</option>
                    <option value="exoplanets">Exoplanets</option>
                    <option value="stars">Stars</option>
                    <option value="galaxies">Galaxies</option>
                    <option value="protoplanets">Protoplanets</option>
                    <option value="nebulas">Nebulas</option>
                    <option value="superclusters">Superclusters</option>
                    <option value="blackHoles">Black Holes</option>
                    <option value="whiteHoles">White Holes</option>
                </select>
            </div>
            <div class="control-group">
                <label>Select Object</label>
                <select id="objectSelect"></select>
            </div>
            <div class="control-group">
                <label>Animation Speed</label>
                <div class="slider-container">
                    <input type="range" id="speedSlider" min="0" max="10" step="0.1" value="0.5">
                    <span id="speedValue">0.5x</span>
                </div>
            </div>
            <div class="control-group">
                <label>Show Orbits/Trails</label>
                <div class="slider-container">
                    <input type="range" id="orbitSlider" min="0" max="1" step="0.1" value="1">
                    <span id="orbitValue">100%</span>
                </div>
            </div>
            <div class="control-group">
                <button id="resetCamera">Reset Camera</button>
                <button id="toggleAnimation">Pause</button>
                <button id="showAllStars" style="margin-top: 5px;">Show All Stars</button>
            </div>
        </div>
        <div id="objectInfo">
            <h3 id="objectName">Object Info</h3>
            <p id="objectDescription"></p>
        </div>
        <div id="info">
            <h3>‚ÑπÔ∏è Controls</h3>
            <p><strong>Mouse:</strong> Drag to rotate, Scroll to zoom</p>
            <p><strong>Click:</strong> Focus on object</p>
            <p><strong>Right-click:</strong> Pan view</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Fallback OrbitControls
        if (typeof THREE.OrbitControls === 'undefined') {
            THREE.OrbitControls = class {
                constructor(camera, domElement) {
                    this.camera = camera;
                    this.domElement = domElement;
                    this.enableDamping = true;
                    this.dampingFactor = 0.05;
                    this.minDistance = 1;
                    this.maxDistance = 10000;
                    this.target = new THREE.Vector3();
                    this.enabled = true;
                    
                    let isDragging = false;
                    let previousMousePosition = { x: 0, y: 0 };
                    
                    domElement.addEventListener('mousedown', (e) => {
                        if (e.button === 0) isDragging = true;
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    });
                    
                    domElement.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        const deltaX = e.clientX - previousMousePosition.x;
                        const deltaY = e.clientY - previousMousePosition.y;
                        
                        const spherical = new THREE.Spherical();
                        spherical.setFromVector3(camera.position.clone().sub(this.target));
                        spherical.theta -= deltaX * 0.01;
                        spherical.phi += deltaY * 0.01;
                        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                        
                        camera.position.setFromSpherical(spherical);
                        camera.position.add(this.target);
                        camera.lookAt(this.target);
                        
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    });
                    
                    domElement.addEventListener('mouseup', () => { isDragging = false; });
                    domElement.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        const distance = camera.position.distanceTo(this.target);
                        const newDistance = distance + e.deltaY * 0.01;
                        const clampedDistance = Math.max(this.minDistance, Math.min(this.maxDistance, newDistance));
                        camera.position.sub(this.target).normalize().multiplyScalar(clampedDistance).add(this.target);
                    });
                }
                update() {
                    if (this.enableDamping) {
                        camera.lookAt(this.target);
                    }
                }
            };
        }
    </script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: false,  // Disabled for better performance
            alpha: true,
            powerPreference: "high-performance"  // Prefer performance over quality
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));  // Cap pixel ratio for performance
        renderer.shadowMap.enabled = false;  // Disable shadows for better performance
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 1;
        controls.maxDistance = 50000;

        // Lighting - more realistic space lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.2);  // Reduced for more dramatic lighting
        scene.add(ambientLight);
        const sunLight = new THREE.PointLight(0xffffff, 3, 10000);
        sunLight.position.set(0, 0, 0);
        scene.add(sunLight);
        
        // Add directional light for better planet shading
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 0, 0);
        scene.add(directionalLight);

        // Stars background - optimized for performance
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({ 
            color: 0xffffff, 
            size: 1.2,  // Slightly larger to compensate for fewer stars
            sizeAttenuation: false  // Stars stay same size regardless of distance
        });
        const starsVertices = [];
        for (let i = 0; i < 5000; i++) {  // Reduced from 30000 for better performance
            const x = (Math.random() - 0.5) * 10000;
            const y = (Math.random() - 0.5) * 10000;
            const z = (Math.random() - 0.5) * 10000;
            starsVertices.push(x, y, z);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Data structures
        const allObjects = {};
        const orbitPaths = {};
        const cometTrails = [];
        const meteorObjects = [];
        const nebulaObjects = [];

        // Celestial object data
        const celestialData = {
            planets: [
                { name: 'Mercury', size: 0.3, color: 0x8c7853, emissive: 0x3a2a1a, distance: 5, speed: 0.12, desc: 'Closest planet to the Sun - Rocky surface with extreme temperature variations' },
                { name: 'Venus', size: 0.4, color: 0xffaa44, emissive: 0xff8844, distance: 7, speed: 0.09, desc: 'Hottest planet in our solar system - Thick toxic atmosphere' },
                { name: 'Earth', size: 0.5, color: 0x4a9eff, emissive: 0x2a5a9f, distance: 10, speed: 0.06, desc: 'Our home planet - The only known planet with life' },
                { name: 'Mars', size: 0.35, color: 0xcd5c5c, emissive: 0x8b3a3a, distance: 15, speed: 0.045, desc: 'The Red Planet - Named for its iron oxide (rust) surface' },
                { name: 'Jupiter', size: 1.2, color: 0xd8ca9d, emissive: 0xb8aa7d, distance: 25, speed: 0.024, hasRings: true, desc: 'Largest planet in our solar system - Gas giant with colorful cloud bands' },
                { name: 'Saturn', size: 1, color: 0xfad5a5, emissive: 0xdaa575, distance: 35, speed: 0.018, desc: 'Famous for its rings - Gas giant with spectacular ring system' },
                { name: 'Uranus', size: 0.7, color: 0x4fd0e7, emissive: 0x2fa0b7, distance: 45, speed: 0.012, hasRings: true, desc: 'Ice giant planet - Tilted on its side, pale blue-green color' },
                { name: 'Neptune', size: 0.7, color: 0x4166f5, emissive: 0x2146d5, distance: 55, speed: 0.009, hasRings: true, desc: 'Farthest planet from the Sun - Deep blue ice giant with strong winds' }
            ],
            dwarfPlanets: [
                { name: 'Pluto', size: 0.2, color: 0x8b7355, distance: 70, speed: 0.006, desc: 'Formerly the 9th planet' },
                { name: 'Ceres', size: 0.15, color: 0x9d9d9d, distance: 18, speed: 0.036, desc: 'Largest object in the asteroid belt' },
                { name: 'Eris', size: 0.22, color: 0xc0c0c0, distance: 90, speed: 0.0045, desc: 'Most massive dwarf planet' },
                { name: 'Haumea', size: 0.18, color: 0x8b7d6b, distance: 75, speed: 0.006, desc: 'Egg-shaped dwarf planet' },
                { name: 'Makemake', size: 0.19, color: 0xa0a0a0, distance: 80, speed: 0.0054, desc: 'Bright dwarf planet' }
            ],
            moons: [
                { name: 'Moon', size: 0.15, color: 0x888888, parent: 'Earth', distance: 1.5, speed: 0.3, desc: 'Earth\'s natural satellite' },
                { name: 'Phobos', size: 0.05, color: 0x666666, parent: 'Mars', distance: 0.8, speed: 0.45, desc: 'Mars\' inner moon' },
                { name: 'Deimos', size: 0.04, color: 0x555555, parent: 'Mars', distance: 1.2, speed: 0.36, desc: 'Mars\' outer moon' },
                { name: 'Io', size: 0.2, color: 0xffd700, parent: 'Jupiter', distance: 2, speed: 0.24, desc: 'Most volcanically active moon' },
                { name: 'Europa', size: 0.18, color: 0x87ceeb, parent: 'Jupiter', distance: 2.5, speed: 0.21, desc: 'Icy moon with subsurface ocean' },
                { name: 'Ganymede', size: 0.25, color: 0x708090, parent: 'Jupiter', distance: 3, speed: 0.18, desc: 'Largest moon in solar system' },
                { name: 'Callisto', size: 0.22, color: 0x2f4f4f, parent: 'Jupiter', distance: 3.5, speed: 0.15, desc: 'Most heavily cratered moon' },
                { name: 'Titan', size: 0.3, color: 0xffa500, parent: 'Saturn', distance: 3, speed: 0.18, desc: 'Saturn\'s largest moon' },
                { name: 'Enceladus', size: 0.1, color: 0xffffff, parent: 'Saturn', distance: 2, speed: 0.24, desc: 'Icy moon with geysers' }
            ],
            meteors: [
                { name: 'Meteor 1', size: 0.02, color: 0xff4444, trail: true, desc: 'Small rocky object' },
                { name: 'Meteor 2', size: 0.03, color: 0xff8844, trail: true, desc: 'Fast-moving space rock' },
                { name: 'Meteor 3', size: 0.025, color: 0xffff44, trail: true, desc: 'Burning meteoroid' }
            ],
            asteroids: [
                { name: 'Ceres', size: 0.15, color: 0x9d9d9d, distance: 18, speed: 0.036, desc: 'Largest object in the asteroid belt - Dwarf planet' },
                { name: 'Vesta', size: 0.12, color: 0x8b7d6b, distance: 19, speed: 0.033, desc: 'Second-largest asteroid in the asteroid belt' },
                { name: 'Pallas', size: 0.11, color: 0x7a6d5a, distance: 20, speed: 0.03, desc: 'Third-largest asteroid' },
                { name: 'Asteroid 433 Eros', size: 0.08, color: 0x6b5d4a, distance: 17, speed: 0.039, desc: 'Near-Earth asteroid' }
            ],
            comets: [
                { name: 'Halley\'s Comet', size: 0.15, color: 0xffffff, distance: 100, speed: 0.003, eccentricity: 0.8, desc: 'Famous periodic comet' },
                { name: 'Comet Hale-Bopp', size: 0.2, color: 0xccccff, distance: 120, speed: 0.0024, eccentricity: 0.9, desc: 'One of the brightest comets' },
                { name: 'Comet 67P', size: 0.12, color: 0xaaaaaa, distance: 80, speed: 0.0036, eccentricity: 0.7, desc: 'Rosetta mission target' }
            ],
            exoplanets: [
                { name: 'Proxima Centauri b', size: 0.6, color: 0x4a9eff, distance: 200, speed: 0.003, hasRings: true, desc: 'Closest known exoplanet - Rocky exoplanet with ring system' },
                { name: 'Kepler-452b', size: 0.7, color: 0x5ab4ff, distance: 250, speed: 0.0024, desc: 'Earth-like exoplanet' },
                { name: 'HD 209458 b', size: 1.5, color: 0xff6b6b, distance: 300, speed: 0.0018, desc: 'Hot Jupiter exoplanet' },
                { name: 'TRAPPIST-1e', size: 0.55, color: 0x6bcaff, distance: 220, speed: 0.0027, desc: 'Potentially habitable exoplanet' },
                { name: 'J1407b', size: 1.8, color: 0x8b7355, distance: 720, speed: 0.0015, hasRings: true, desc: 'Brown dwarf or giant planet with massive ring system - Rings are 200 times larger than Saturn\'s rings!' },
                { name: 'J1407c', size: 0.5, color: 0x6b9c8f, distance: 725, speed: 0.0012, desc: 'Exoplanet in J1407 system' },
                { name: 'J1407d', size: 0.4, color: 0x7ba5a5, distance: 730, speed: 0.001, desc: 'Exoplanet in J1407 system' },
                { name: 'HIP 41378f', size: 0.9, color: 0x5a8cff, distance: 280, speed: 0.0021, hasRings: true, desc: 'Gas giant exoplanet with prominent ring system - Located in the HIP 41378 system' }
            ],
            stars: [
                { name: 'Sun', size: 2, color: 0xffaa00, distance: 0, speed: 0, desc: 'G-type main sequence star (Yellow Dwarf) - Our star that provides light and heat to Earth. The Sun is a star just like all the other stars in the sky, but it\'s much closer to us!' },
                { name: 'Sirius', size: 2.5, color: 0xffffff, distance: 500, speed: 0, desc: 'A-type main sequence star - Brightest star in night sky, also called the Dog Star' },
                { name: 'Betelgeuse', size: 8, color: 0xff4444, distance: 600, speed: 0, desc: 'M-type red supergiant star - One of the largest stars known, located in Orion constellation' },
                { name: 'Vega', size: 2.2, color: 0xaaccff, distance: 550, speed: 0, desc: 'A-type main sequence star - Blue-white star, one of the brightest in the sky' },
                { name: 'Proxima Centauri', size: 0.3, color: 0xff6666, distance: 200, speed: 0, desc: 'M-type red dwarf star - Closest star to Sun, part of Alpha Centauri system' },
                { name: 'Rigel', size: 6, color: 0x88ccff, distance: 580, speed: 0, desc: 'B-type blue supergiant star - Bright blue star in Orion constellation' },
                { name: 'Arcturus', size: 3.5, color: 0xff8844, distance: 520, speed: 0, desc: 'K-type red giant star - Orange giant star, brightest in northern hemisphere' },
                { name: 'Polaris', size: 2.8, color: 0xffffaa, distance: 510, speed: 0, desc: 'F-type supergiant star - The North Star, used for navigation' },
                { name: 'Antares', size: 7, color: 0xff3333, distance: 590, speed: 0, desc: 'M-type red supergiant star - Red supergiant in Scorpius constellation' },
                { name: 'Alpha Centauri A', size: 1.8, color: 0xffffcc, distance: 200, speed: 0, desc: 'G-type main sequence star - Similar to our Sun, part of triple star system' },
                { name: 'Stephenson 2-18', size: 15, color: 0xff2222, distance: 650, speed: 0, desc: 'Red supergiant star - One of the largest known stars in the universe, located in the Stephenson 2 star cluster' },
                { name: 'UY Scuti', size: 14, color: 0xff3333, distance: 640, speed: 0, desc: 'M-type red supergiant star - One of the largest known stars, located in Scutum constellation. If placed at the center of our solar system, it would extend beyond Jupiter\'s orbit!' },
                { name: 'VY Canis Majoris', size: 12, color: 0xff4444, distance: 620, speed: 0, desc: 'M-type red supergiant star - One of the largest and most luminous stars known, located in Canis Major constellation' },
                { name: 'Aldebaran', size: 4.5, color: 0xff6644, distance: 540, speed: 0, desc: 'K-type red giant star - The "eye" of the Taurus constellation. Orange-red giant star, one of the brightest stars in the night sky' },
                { name: 'Elnath', size: 3.2, color: 0xaaccff, distance: 560, speed: 0, desc: 'B-type blue giant star - Beta Tauri, the second brightest star in Taurus constellation. Blue-white giant star' },
                { name: 'Pollux', size: 4.0, color: 0xff8844, distance: 530, speed: 0, desc: 'K-type orange giant star - Beta Geminorum, the brightest star in Gemini constellation. Orange giant star, larger and brighter than the Sun' },
                { name: 'J1407', size: 1.5, color: 0xffcc88, distance: 700, speed: 0, desc: 'K-type main sequence star - Young star in Centaurus constellation, host to the J1407 system with massive ring system' }
            ],
            galaxies: [
                { name: 'Milky Way', size: 50, color: 0x4a4aff, type: 'spiral', desc: 'Our home galaxy' },
                { name: 'Andromeda', size: 60, color: 0x5a5aff, type: 'spiral', desc: 'Nearest major galaxy' },
                { name: 'Triangulum', size: 30, color: 0x6a6aff, type: 'spiral', desc: 'Third largest galaxy in Local Group' },
                { name: 'Sombrero', size: 40, color: 0x7a7aff, type: 'spiral', desc: 'Edge-on spiral galaxy' }
            ],
            protoplanets: [
                { name: 'Protoplanet Alpha', size: 0.4, color: 0xff8844, distance: 12, speed: 0.054, desc: 'Early stage planet formation' },
                { name: 'Protoplanet Beta', size: 0.35, color: 0xffaa44, distance: 20, speed: 0.03, desc: 'Accreting material' },
                { name: 'Protoplanet Gamma', size: 0.3, color: 0xffcc44, distance: 28, speed: 0.021, desc: 'Forming planetary core' }
            ],
            nebulas: [
                { name: 'Orion Nebula', size: 15, color: 0xff44ff, position: [1000, 0, 0], desc: 'Star-forming region' },
                { name: 'Crab Nebula', size: 12, color: 0x44ffff, position: [1200, 200, -300], desc: 'Supernova remnant' },
                { name: 'Horsehead Nebula', size: 10, color: 0xff8844, position: [1100, -200, 400], desc: 'Dark nebula' },
                { name: 'Eagle Nebula', size: 18, color: 0x44ff44, position: [1300, 300, 200], desc: 'Pillars of Creation' }
            ],
            superclusters: [
                { name: 'Laniakea', size: 200, color: 0x8844ff, position: [5000, 0, 0], desc: 'Our supercluster' },
                { name: 'Virgo Supercluster', size: 150, color: 0x9944ff, position: [6000, 1000, -500], desc: 'Part of Laniakea' },
                { name: 'Great Attractor', size: 180, color: 0xaa44ff, position: [5500, -500, 1000], desc: 'Gravitational anomaly' }
            ],
            blackHoles: [
                { name: 'Sagittarius A*', size: 0.5, color: 0x000000, distance: 700, speed: 0, desc: 'Supermassive black hole at the center of the Milky Way galaxy, 4 million times the mass of the Sun' },
                { name: 'M87 Black Hole', size: 0.8, color: 0x000000, distance: 800, speed: 0, desc: 'First black hole ever photographed - Supermassive black hole in the center of Messier 87 galaxy' },
                { name: 'Cygnus X-1', size: 0.3, color: 0x000000, distance: 750, speed: 0, desc: 'Stellar-mass black hole - First confirmed black hole, located in Cygnus constellation' },
                { name: 'TON 618', size: 2.5, color: 0x000000, distance: 1000, speed: 0, desc: 'Ultramassive black hole - One of the most massive black holes known, 66 billion times the mass of the Sun! Located in Canes Venatici constellation' },
                { name: 'Phoenix A', size: 3.0, color: 0x000000, distance: 1100, speed: 0, desc: 'Ultramassive black hole - One of the largest known black holes, estimated at 100 billion times the mass of the Sun! Located in Phoenix constellation' }
            ],
            whiteHoles: [
                { name: 'GRB 060614-WH', size: 1.0, color: 0xffffff, distance: 900, speed: 0, desc: 'Theoretical white hole candidate - A hypothetical region of spacetime that cannot be entered from the outside, but matter and light can escape from it. Named after gamma-ray burst GRB 060614, which some theories suggest could be evidence of a white hole. White holes are purely theoretical and have never been confirmed, but remain an intriguing possibility in general relativity.' },
                { name: 'GRB 080319B-WH', size: 1.2, color: 0xffffff, distance: 950, speed: 0, desc: 'Theoretical white hole candidate - Named after the "Naked Eye Burst" GRB 080319B, one of the brightest gamma-ray bursts ever observed. Some theoretical models suggest such extreme energy releases could indicate white hole activity.' },
                { name: 'WH-3C 273', size: 0.8, color: 0xffffff, distance: 850, speed: 0, desc: 'Theoretical white hole candidate - Hypothetical white hole counterpart to quasar 3C 273. Some theories propose that quasars might be connected to white holes through wormholes.' },
                { name: 'Sagittarius A*-WH', size: 1.5, color: 0xffffff, distance: 700, speed: 0, desc: 'Theoretical white hole - Hypothetical white hole counterpart to Sagittarius A*. Some models suggest black holes and white holes could be connected through Einstein-Rosen bridges (wormholes).' },
                { name: 'M87-WH', size: 1.3, color: 0xffffff, distance: 800, speed: 0, desc: 'Theoretical white hole - Hypothetical white hole counterpart to the M87 black hole. Could theoretically exist as the "other end" of a wormhole connecting to the M87 black hole.' },
                { name: 'TON 618-WH', size: 2.8, color: 0xffffff, distance: 1000, speed: 0, desc: 'Theoretical white hole - Hypothetical white hole counterpart to ultramassive black hole TON 618. If connected via wormhole, this would be one of the largest theoretical white holes.' },
                { name: 'Phoenix A-WH', size: 3.2, color: 0xffffff, distance: 1100, speed: 0, desc: 'Theoretical white hole - Hypothetical white hole counterpart to ultramassive black hole Phoenix A. Could theoretically be the largest white hole if connected through spacetime.' }
            ]
        };

        // Create celestial objects
        function createPlanet(data) {
            // Increased segments slightly for better realism (20 instead of 16)
            const geometry = new THREE.SphereGeometry(data.size, 20, 20);
            
            // More realistic materials with proper shading
            const material = new THREE.MeshPhongMaterial({
                color: data.color,
                emissive: data.emissive || data.color,
                emissiveIntensity: 0.15,
                shininess: 30,
                specular: 0x222222,
                reflectivity: 0.1
            });
            
            const planet = new THREE.Mesh(geometry, material);
            planet.userData = { ...data, type: 'planet' };
            
            // Special handling for specific planets
            if (data.name === 'Earth') {
                // Earth gets a more vibrant blue with green tint
                material.color = new THREE.Color(0x4a9eff);
                material.emissive = new THREE.Color(0x2a5a9f);
            } else if (data.name === 'Jupiter') {
                // Jupiter base color - warm tan/orange
                material.color = new THREE.Color(0xd8ca9d);
                material.emissive = new THREE.Color(0xb8aa7d);
                material.emissiveIntensity = 0.2;
                material.shininess = 15;
                material.specular = new THREE.Color(0x333333);
            } else if (data.name === 'Venus') {
                // Venus gets a brighter, more yellowish appearance
                material.emissiveIntensity = 0.25;
            } else if (data.name === 'Neptune') {
                // Neptune gets a deeper blue
                material.color = new THREE.Color(0x4166f5);
                material.emissive = new THREE.Color(0x2146d5);
            }
            
            if (data.distance > 0) {
                planet.userData.angle = Math.random() * Math.PI * 2;
            }
            return planet;
        }

        function createEarthContinents(planetSize) {
            const continentGroup = new THREE.Group();
            
            // Create more realistic continent shapes using flattened geometries
            // Better positioned and sized to look like actual landmasses
            const continents = [
                // North America - larger, more spread out
                { width: planetSize * 0.4, height: planetSize * 0.3, color: 0x5a8c4a, lat: 0.6, lon: -0.3 },
                { width: planetSize * 0.25, height: planetSize * 0.2, color: 0x4a7c3a, lat: 0.7, lon: -0.1 },
                // South America - elongated
                { width: planetSize * 0.2, height: planetSize * 0.35, color: 0x4a7c3a, lat: -0.2, lon: -0.4 },
                // Africa - large continent
                { width: planetSize * 0.3, height: planetSize * 0.4, color: 0x5a8c4a, lat: 0.0, lon: 0.2 },
                // Europe - smaller
                { width: planetSize * 0.2, height: planetSize * 0.15, color: 0x4a7c3a, lat: 0.7, lon: 0.1 },
                // Asia - very large
                { width: planetSize * 0.5, height: planetSize * 0.35, color: 0x5a8c4a, lat: 0.4, lon: 0.5 },
                { width: planetSize * 0.3, height: planetSize * 0.25, color: 0x4a7c3a, lat: 0.5, lon: 0.6 },
                // Australia - small island continent
                { width: planetSize * 0.18, height: planetSize * 0.12, color: 0x6a9c5a, lat: -0.5, lon: 0.6 }
            ];
            
            continents.forEach(continent => {
                // Create a flat plane geometry for more realistic continent shape
                const continentGeometry = new THREE.PlaneGeometry(continent.width, continent.height, 8, 8);
                
                // Add some randomness to make it look more natural
                const positions = continentGeometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const noise = (Math.random() - 0.5) * planetSize * 0.05;
                    positions.setXYZ(i, x + noise, y + noise, 0);
                }
                positions.needsUpdate = true;
                
                const continentMaterial = new THREE.MeshPhongMaterial({
                    color: continent.color,
                    emissive: continent.color,
                    emissiveIntensity: 0.08,
                    shininess: 15,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.95
                });
                const continentPatch = new THREE.Mesh(continentGeometry, continentMaterial);
                
                // Convert lat/lon to 3D position on sphere
                const lat = continent.lat * Math.PI / 2; // latitude in radians
                const lon = continent.lon * Math.PI; // longitude in radians
                const radius = planetSize * 1.005; // Slightly above surface
                
                const x = Math.cos(lat) * Math.cos(lon) * radius;
                const y = Math.sin(lat) * radius;
                const z = Math.cos(lat) * Math.sin(lon) * radius;
                
                continentPatch.position.set(x, y, z);
                
                // Orient the plane to be tangent to the sphere surface
                const normal = new THREE.Vector3(x, y, z).normalize();
                continentPatch.lookAt(normal.multiplyScalar(planetSize * 2));
                continentPatch.rotateX(Math.PI / 2);
                
                continentGroup.add(continentPatch);
            });
            
            return continentGroup;
        }

        function createSaturnRings(planetSize) {
            const ringGroup = new THREE.Group();
            
            // Create multiple ring layers for a more realistic look with better colors
            const ringLayers = [
                { innerRadius: planetSize * 1.2, outerRadius: planetSize * 1.8, color: 0xe8d5a4, opacity: 0.9 },
                { innerRadius: planetSize * 1.8, outerRadius: planetSize * 2.2, color: 0xd4a574, opacity: 0.7 },
                { innerRadius: planetSize * 2.2, outerRadius: planetSize * 2.6, color: 0xc49564, opacity: 0.6 },
                { innerRadius: planetSize * 2.6, outerRadius: planetSize * 3.0, color: 0xb48554, opacity: 0.5 },
                { innerRadius: planetSize * 3.0, outerRadius: planetSize * 3.4, color: 0xa47544, opacity: 0.4 },
                { innerRadius: planetSize * 3.4, outerRadius: planetSize * 3.8, color: 0x946534, opacity: 0.3 }
            ];
            
            ringLayers.forEach(layer => {
                const ringGeometry = new THREE.RingGeometry(layer.innerRadius, layer.outerRadius, 128);  // More segments for smoother rings
                const ringMaterial = new THREE.MeshPhongMaterial({
                    color: layer.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: layer.opacity,
                    emissive: layer.color,
                    emissiveIntensity: 0.3,
                    shininess: 30,
                    specular: 0x444444
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2; // Lay flat (horizontal)
                ringGroup.add(ring);
            });
            
            return ringGroup;
        }

        function createJupiterRings(planetSize) {
            const ringGroup = new THREE.Group();
            
            // Jupiter has faint, dark rings - much subtler than Saturn's
            const ringLayers = [
                { innerRadius: planetSize * 1.15, outerRadius: planetSize * 1.35, color: 0x3a2a1a, opacity: 0.3 },
                { innerRadius: planetSize * 1.35, outerRadius: planetSize * 1.55, color: 0x2a1a0a, opacity: 0.2 },
                { innerRadius: planetSize * 1.55, outerRadius: planetSize * 1.75, color: 0x1a0a00, opacity: 0.15 }
            ];
            
            ringLayers.forEach(layer => {
                const ringGeometry = new THREE.RingGeometry(layer.innerRadius, layer.outerRadius, 128);
                const ringMaterial = new THREE.MeshPhongMaterial({
                    color: layer.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: layer.opacity,
                    emissive: layer.color,
                    emissiveIntensity: 0.1,
                    shininess: 10,
                    specular: 0x111111
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ringGroup.add(ring);
            });
            
            return ringGroup;
        }

        function createUranusRings(planetSize) {
            const ringGroup = new THREE.Group();
            
            // Uranus has dark, narrow rings
            const ringLayers = [
                { innerRadius: planetSize * 1.2, outerRadius: planetSize * 1.35, color: 0x1a2a3a, opacity: 0.4 },
                { innerRadius: planetSize * 1.4, outerRadius: planetSize * 1.5, color: 0x0a1a2a, opacity: 0.3 },
                { innerRadius: planetSize * 1.55, outerRadius: planetSize * 1.7, color: 0x1a2a3a, opacity: 0.35 },
                { innerRadius: planetSize * 1.75, outerRadius: planetSize * 1.9, color: 0x0a1a2a, opacity: 0.25 },
                { innerRadius: planetSize * 1.95, outerRadius: planetSize * 2.15, color: 0x1a2a3a, opacity: 0.3 }
            ];
            
            ringLayers.forEach(layer => {
                const ringGeometry = new THREE.RingGeometry(layer.innerRadius, layer.outerRadius, 128);
                const ringMaterial = new THREE.MeshPhongMaterial({
                    color: layer.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: layer.opacity,
                    emissive: layer.color,
                    emissiveIntensity: 0.15,
                    shininess: 20,
                    specular: 0x222222
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ringGroup.add(ring);
            });
            
            return ringGroup;
        }

        function createNeptuneRings(planetSize) {
            const ringGroup = new THREE.Group();
            
            // Neptune has incomplete, clumpy rings
            const ringLayers = [
                { innerRadius: planetSize * 1.2, outerRadius: planetSize * 1.4, color: 0x1a1a3a, opacity: 0.35 },
                { innerRadius: planetSize * 1.45, outerRadius: planetSize * 1.6, color: 0x0a0a2a, opacity: 0.3 },
                { innerRadius: planetSize * 1.65, outerRadius: planetSize * 1.85, color: 0x1a1a3a, opacity: 0.3 },
                { innerRadius: planetSize * 1.9, outerRadius: planetSize * 2.1, color: 0x0a0a2a, opacity: 0.25 }
            ];
            
            ringLayers.forEach(layer => {
                const ringGeometry = new THREE.RingGeometry(layer.innerRadius, layer.outerRadius, 128);
                const ringMaterial = new THREE.MeshPhongMaterial({
                    color: layer.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: layer.opacity,
                    emissive: layer.color,
                    emissiveIntensity: 0.12,
                    shininess: 15,
                    specular: 0x222222
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ringGroup.add(ring);
            });
            
            return ringGroup;
        }

        function createJupiterCloudBands(planetSize) {
            const cloudGroup = new THREE.Group();
            
            // Realistic Jupiter cloud bands matching actual planet appearance
            // More bands with accurate colors and varying widths
            const bands = [
                { y: 0.80, height: 0.11, color: 0xe0d4c0, opacity: 0.87 }, // North polar zone
                { y: 0.68, height: 0.10, color: 0x6b4a2a, opacity: 0.92 }, // North temperate belt (darker)
                { y: 0.58, height: 0.12, color: 0xf0e4c0, opacity: 0.85 }, // North temperate zone
                { y: 0.46, height: 0.09, color: 0x7a4a2a, opacity: 0.91 }, // North tropical belt
                { y: 0.36, height: 0.13, color: 0xf5e8d0, opacity: 0.84 }, // North tropical zone
                { y: 0.24, height: 0.10, color: 0x8b5a3a, opacity: 0.90 }, // North equatorial belt
                { y: 0.10, height: 0.19, color: 0xf8ead5, opacity: 0.86 }, // Equatorial zone (wider, lighter)
                { y: -0.10, height: 0.11, color: 0x7a4a2a, opacity: 0.91 }, // South equatorial belt
                { y: -0.26, height: 0.13, color: 0xf0e4c0, opacity: 0.84 }, // South tropical zone
                { y: -0.40, height: 0.10, color: 0x6b4a2a, opacity: 0.90 }, // South tropical belt
                { y: -0.52, height: 0.12, color: 0xe8dcc8, opacity: 0.86 }, // South temperate zone
                { y: -0.64, height: 0.09, color: 0x5a3a1a, opacity: 0.89 }, // South temperate belt
                { y: -0.74, height: 0.11, color: 0xd0c4a8, opacity: 0.85 }, // South temperate zone
                { y: -0.84, height: 0.08, color: 0x4a2a0a, opacity: 0.87 }, // South polar belt
                { y: -0.92, height: 0.06, color: 0x8aa4b8, opacity: 0.70 }  // South polar region (blue-green tones)
            ];
            
            bands.forEach(band => {
                // Calculate the radius at this latitude - paint directly on surface
                const lat = Math.asin(band.y);
                const radius = Math.cos(lat) * planetSize;
                const bandRadius = radius; // Exactly on surface, like painting on a wall
                
                // Create cylinder segment with moderate detail for performance
                const bandGeometry = new THREE.CylinderGeometry(
                    bandRadius, 
                    bandRadius, 
                    planetSize * band.height, 
                    64, // Good balance of detail and performance
                    1, 
                    true // openEnded
                );
                
                const bandMaterial = new THREE.MeshPhongMaterial({
                    color: band.color,
                    emissive: band.color,
                    emissiveIntensity: 0.15,
                    transparent: true,
                    opacity: band.opacity,
                    shininess: 20,
                    specular: 0x222222,
                    side: THREE.DoubleSide,
                    depthWrite: false // Blend better with planet surface
                });
                const bandMesh = new THREE.Mesh(bandGeometry, bandMaterial);
                bandMesh.rotation.z = Math.PI / 2; // Rotate to horizontal
                bandMesh.position.y = band.y * planetSize;
                cloudGroup.add(bandMesh);
            });
            
            // Add Great Red Spot - realistic with lighter center
            const redSpotRadius = planetSize * 0.22;
            
            // Outer darker ring of Great Red Spot
            const redSpotOuterGeometry = new THREE.SphereGeometry(redSpotRadius, 48, 48);
            const redSpotOuterMaterial = new THREE.MeshPhongMaterial({
                color: 0xcc5522,
                emissive: 0xaa3311,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.90,
                shininess: 18,
                specular: 0x332222,
                depthWrite: false
            });
            const redSpotOuter = new THREE.Mesh(redSpotOuterGeometry, redSpotOuterMaterial);
            const spotLat = -0.28; // Southern hemisphere, lower position
            const spotLon = 0.22; // Visible from side
            const spotRadius = planetSize;
            redSpotOuter.position.set(
                Math.cos(spotLat) * Math.cos(spotLon) * spotRadius,
                Math.sin(spotLat) * spotRadius,
                Math.cos(spotLat) * Math.sin(spotLon) * spotRadius
            );
            redSpotOuter.scale.set(1.6, 0.88, 1.0); // Oval shape
            redSpotOuter.lookAt(0, 0, 0);
            redSpotOuter.rotateX(Math.PI / 2);
            cloudGroup.add(redSpotOuter);
            
            // Inner lighter center of Great Red Spot
            const redSpotInnerGeometry = new THREE.SphereGeometry(redSpotRadius * 0.55, 32, 32);
            const redSpotInnerMaterial = new THREE.MeshPhongMaterial({
                color: 0xf5c8a8,
                emissive: 0xe5b898,
                emissiveIntensity: 0.25,
                transparent: true,
                opacity: 0.82,
                shininess: 20,
                specular: 0x444422,
                depthWrite: false
            });
            const redSpotInner = new THREE.Mesh(redSpotInnerGeometry, redSpotInnerMaterial);
            redSpotInner.position.copy(redSpotOuter.position);
            redSpotInner.scale.set(1.4, 0.78, 1.0);
            redSpotInner.lookAt(0, 0, 0);
            redSpotInner.rotateX(Math.PI / 2);
            cloudGroup.add(redSpotInner);
            
            // Add white oval storms below Great Red Spot (matching real Jupiter)
            const whiteOvalStorms = [
                { lat: -0.42, lon: 0.18, size: 0.12, scaleX: 1.7, scaleY: 0.82 },
                { lat: -0.48, lon: 0.38, size: 0.10, scaleX: 1.6, scaleY: 0.78 },
                { lat: -0.52, lon: 0.08, size: 0.11, scaleX: 1.8, scaleY: 0.85 }
            ];
            
            whiteOvalStorms.forEach(storm => {
                const stormGeometry = new THREE.SphereGeometry(planetSize * storm.size, 28, 28);
                const stormMaterial = new THREE.MeshPhongMaterial({
                    color: 0xf5f5e8,
                    emissive: 0xe5e5d8,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 0.76,
                    shininess: 25,
                    specular: 0x444444,
                    depthWrite: false
                });
                const stormMesh = new THREE.Mesh(stormGeometry, stormMaterial);
                const stormPos = new THREE.Vector3(
                    Math.cos(storm.lat) * Math.cos(storm.lon) * planetSize,
                    Math.sin(storm.lat) * planetSize,
                    Math.cos(storm.lat) * Math.sin(storm.lon) * planetSize
                );
                stormMesh.position.copy(stormPos);
                stormMesh.scale.set(storm.scaleX, storm.scaleY, 1.0);
                stormMesh.lookAt(0, 0, 0);
                stormMesh.rotateX(Math.PI / 2);
                cloudGroup.add(stormMesh);
            });
            
            return cloudGroup;
        }

        function createExoplanetRings(planetSize, ringColor = 0x6b8cff) {
            const ringGroup = new THREE.Group();
            
            // Create rings for exoplanets - moderate size, colorful
            const ringLayers = [
                { innerRadius: planetSize * 1.2, outerRadius: planetSize * 1.6, color: ringColor, opacity: 0.7 },
                { innerRadius: planetSize * 1.6, outerRadius: planetSize * 2.0, color: ringColor, opacity: 0.6 },
                { innerRadius: planetSize * 2.0, outerRadius: planetSize * 2.4, color: ringColor, opacity: 0.5 },
                { innerRadius: planetSize * 2.4, outerRadius: planetSize * 2.8, color: ringColor, opacity: 0.4 }
            ];
            
            ringLayers.forEach(layer => {
                const ringGeometry = new THREE.RingGeometry(layer.innerRadius, layer.outerRadius, 128);
                const ringMaterial = new THREE.MeshPhongMaterial({
                    color: layer.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: layer.opacity,
                    emissive: layer.color,
                    emissiveIntensity: 0.25,
                    shininess: 30,
                    specular: 0x444444
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2; // Lay flat (horizontal)
                ringGroup.add(ring);
            });
            
            return ringGroup;
        }

        function createJ1407bRings(planetSize) {
            const ringGroup = new THREE.Group();
            
            // J1407b has MASSIVE rings - 200 times larger than Saturn's!
            // Create many more ring layers to show the enormous size
            const ringLayers = [
                { innerRadius: planetSize * 1.3, outerRadius: planetSize * 2.0, color: 0xd4a574, opacity: 0.8 },
                { innerRadius: planetSize * 2.0, outerRadius: planetSize * 3.0, color: 0xc49564, opacity: 0.7 },
                { innerRadius: planetSize * 3.0, outerRadius: planetSize * 4.5, color: 0xb48554, opacity: 0.6 },
                { innerRadius: planetSize * 4.5, outerRadius: planetSize * 6.5, color: 0xa47544, opacity: 0.5 },
                { innerRadius: planetSize * 6.5, outerRadius: planetSize * 9.0, color: 0x946534, opacity: 0.4 },
                { innerRadius: planetSize * 9.0, outerRadius: planetSize * 12.0, color: 0x845524, opacity: 0.3 },
                { innerRadius: planetSize * 12.0, outerRadius: planetSize * 16.0, color: 0x744514, opacity: 0.25 },
                { innerRadius: planetSize * 16.0, outerRadius: planetSize * 20.0, color: 0x643504, opacity: 0.2 }
            ];
            
            ringLayers.forEach(layer => {
                const ringGeometry = new THREE.RingGeometry(layer.innerRadius, layer.outerRadius, 128);
                const ringMaterial = new THREE.MeshPhongMaterial({
                    color: layer.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: layer.opacity,
                    emissive: layer.color,
                    emissiveIntensity: 0.3,
                    shininess: 30,
                    specular: 0x444444
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2; // Lay flat (horizontal)
                ringGroup.add(ring);
            });
            
            return ringGroup;
        }

        function createMoon(data, parentPlanet) {
            const geometry = new THREE.SphereGeometry(data.size, 16, 16);  // Increased for better realism
            const material = new THREE.MeshPhongMaterial({
                color: data.color,
                emissive: data.color,
                emissiveIntensity: 0.08,
                shininess: 20,
                specular: 0x111111
            });
            const moon = new THREE.Mesh(geometry, material);
            moon.userData = { ...data, type: 'moon', parent: parentPlanet };
            moon.userData.angle = Math.random() * Math.PI * 2;
            return moon;
        }

        function createComet(data) {
            const geometry = new THREE.SphereGeometry(data.size, 16, 16);  // Increased for better realism
            const material = new THREE.MeshPhongMaterial({
                color: data.color,
                emissive: data.color,
                emissiveIntensity: 0.5,
                shininess: 50
            });
            const comet = new THREE.Mesh(geometry, material);
            comet.userData = { ...data, type: 'comet' };
            comet.userData.angle = Math.random() * Math.PI * 2;
            
            // Create more realistic trail with gradient
            const trailGeometry = new THREE.BufferGeometry();
            const trailMaterial = new THREE.LineBasicMaterial({
                color: 0x88ffff,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            trail.userData.points = [];
            comet.userData.trail = trail;
            
            return comet;
        }

        function createMeteor(data) {
            const geometry = new THREE.OctahedronGeometry(data.size, 1);  // Added detail
            const material = new THREE.MeshPhongMaterial({
                color: data.color,
                emissive: data.color,
                emissiveIntensity: 1.0,
                shininess: 100
            });
            const meteor = new THREE.Mesh(geometry, material);
            meteor.userData = { ...data, type: 'meteor' };
            meteor.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            );
            meteor.position.set(
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 100
            );
            return meteor;
        }

        function createAsteroid(data) {
            // Create irregular asteroid shape using IcosahedronGeometry for more detail
            const geometry = new THREE.IcosahedronGeometry(data.size, 0);
            // Add some randomness to make it look more irregular
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                const noise = (Math.random() - 0.5) * data.size * 0.3;
                positions.setXYZ(i, x + noise, y + noise, z + noise);
            }
            positions.needsUpdate = true;
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                color: data.color,
                emissive: data.color,
                emissiveIntensity: 0.1,
                shininess: 10,
                specular: 0x111111
            });
            const asteroid = new THREE.Mesh(geometry, material);
            asteroid.userData = { ...data, type: 'asteroid' };
            if (data.distance > 0) {
                asteroid.userData.angle = Math.random() * Math.PI * 2;
            }
            return asteroid;
        }

        function createGalaxy(data) {
            const group = new THREE.Group();
            group.userData = { ...data, type: 'galaxy' };
            
            // Create spiral structure - optimized with fewer particles
            // Use Points instead of individual meshes for better performance
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesMaterial = new THREE.PointsMaterial({
                color: data.color,
                size: 0.3,
                transparent: true,
                opacity: 0.8
            });
            const particles = [];
            for (let i = 0; i < 1000; i++) {  // Reduced from 5000 to 1000
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * data.size;
                const spiral = angle + radius * 0.1;
                const x = Math.cos(spiral) * radius;
                const z = Math.sin(spiral) * radius;
                const y = (Math.random() - 0.5) * data.size * 0.1;
                particles.push(x, y, z);
            }
            particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particles, 3));
            const points = new THREE.Points(particlesGeometry, particlesMaterial);
            group.add(points);
            
            return group;
        }

        function createNebula(data) {
            const group = new THREE.Group();
            group.userData = { ...data, type: 'nebula' };
            
            // Create particle cloud - optimized with fewer particles
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesMaterial = new THREE.PointsMaterial({
                color: data.color,
                size: 0.8,  // Slightly larger to compensate for fewer particles
                transparent: true,
                opacity: 0.6
            });
            const particles = [];
            for (let i = 0; i < 500; i++) {  // Reduced from 2000 to 500
                const x = (Math.random() - 0.5) * data.size;
                const y = (Math.random() - 0.5) * data.size;
                const z = (Math.random() - 0.5) * data.size;
                particles.push(x, y, z);
            }
            particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particles, 3));
            const points = new THREE.Points(particlesGeometry, particlesMaterial);
            group.add(points);
            
            return group;
        }

        function createSupercluster(data) {
            const group = new THREE.Group();
            group.userData = { ...data, type: 'supercluster' };
            
            // Create galaxy cluster representation - optimized with fewer galaxies
            for (let i = 0; i < 50; i++) {  // Reduced from 100 to 50
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * data.size * 0.5;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = (Math.random() - 0.5) * data.size * 0.2;
                
                const galaxyGeometry = new THREE.SphereGeometry(2, 6, 6);  // Reduced from 8 to 6
                const galaxyMaterial = new THREE.MeshBasicMaterial({
                    color: data.color,
                    emissive: data.color,
                    emissiveIntensity: 0.8
                });
                const galaxy = new THREE.Mesh(galaxyGeometry, galaxyMaterial);
                galaxy.position.set(x, y, z);
                group.add(galaxy);
            }
            
            return group;
        }

        function createBlackHole(data) {
            const group = new THREE.Group();
            group.userData = { ...data, type: 'blackHole' };
            
            // Black hole shadow - roughly twice the size of event horizon
            const shadowRadius = data.size * 2;
            const shadowGeometry = new THREE.SphereGeometry(shadowRadius, 32, 32);
            const shadowMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                side: THREE.BackSide // Render from inside
            });
            const shadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
            group.add(shadow);
            
            // Create main accretion disk with Doppler beaming (brighter on left, fainter on right)
            const innerDiskRadius = data.size * 2.2;
            const midDiskRadius = data.size * 3.5;
            const outerDiskRadius = data.size * 5;
            
            // Create custom geometry for Doppler beaming effect
            function createDopplerDisk(innerR, outerR, segments = 128) {
                const geometry = new THREE.RingGeometry(innerR, outerR, segments);
                const positions = geometry.attributes.position;
                const colors = [];
                const color = new THREE.Color();
                
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const z = positions.getZ(i);
                    const angle = Math.atan2(z, x);
                    
                    // Doppler beaming: brighter on left (angle ~ -œÄ/2), fainter on right (angle ~ œÄ/2)
                    const dopplerFactor = (Math.cos(angle) + 1) / 2; // 0 to 1, peaks at left
                    const brightness = 0.4 + dopplerFactor * 0.6; // 40% to 100% brightness
                    
                    // Radial gradient: brighter closer to black hole
                    const radius = Math.sqrt(x * x + z * z);
                    const radialFactor = 1 - (radius - innerR) / (outerR - innerR);
                    const finalBrightness = brightness * (0.5 + radialFactor * 0.5);
                    
                    // Orange-red color gradient
                    const hue = 0.08 - radialFactor * 0.05; // Orange to red
                    color.setHSL(hue, 0.9, finalBrightness * 0.5);
                    colors.push(color.r, color.g, color.b);
                }
                
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                return geometry;
            }
            
            // Inner hot disk with Doppler beaming
            const innerDiskGeometry = createDopplerDisk(innerDiskRadius, midDiskRadius, 128);
            const innerDiskMaterial = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.95,
                vertexColors: true,
                emissive: 0xff4400,
                emissiveIntensity: 0.8
            });
            const innerDisk = new THREE.Mesh(innerDiskGeometry, innerDiskMaterial);
            innerDisk.rotation.x = -Math.PI / 2;
            group.add(innerDisk);
            
            // Outer disk with Doppler beaming
            const outerDiskGeometry = createDopplerDisk(midDiskRadius, outerDiskRadius, 128);
            const outerDiskMaterial = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.75,
                vertexColors: true,
                emissive: 0xff2200,
                emissiveIntensity: 0.6
            });
            const outerDisk = new THREE.Mesh(outerDiskGeometry, outerDiskMaterial);
            outerDisk.rotation.x = -Math.PI / 2;
            group.add(outerDisk);
            
            // Photon ring - thin, bright orange-red ring close to black hole shadow
            const photonRingRadius = shadowRadius * 1.1;
            const photonRingGeometry = new THREE.RingGeometry(photonRingRadius, photonRingRadius * 1.05, 256);
            const photonRingMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4400,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9,
                emissive: 0xff6600,
                emissiveIntensity: 1.2
            });
            const photonRing = new THREE.Mesh(photonRingGeometry, photonRingMaterial);
            photonRing.rotation.x = -Math.PI / 2;
            group.add(photonRing);
            
            // Gravitational lensing: Image of the disk's far side (curved arc above)
            function createLensedArc(radius, curvature, segments = 64) {
                const vertices = [];
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const angle = (t - 0.5) * Math.PI * 0.8; // Arc span
                    const x = Math.cos(angle) * radius;
                    const y = curvature * (1 - Math.abs(angle) / (Math.PI * 0.4)); // Curved upward/downward
                    const z = Math.sin(angle) * radius * 0.3;
                    vertices.push(x, y, z);
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                return geometry;
            }
            
            // Far side lensed image (above)
            const farSideGeometry = createLensedArc(outerDiskRadius * 0.9, shadowRadius * 1.5, 64);
            const farSideMaterial = new THREE.LineBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            const farSide = new THREE.Line(farSideGeometry, farSideMaterial);
            farSide.rotation.x = -Math.PI / 2;
            group.add(farSide);
            
            // Underside lensed image (below)
            const undersideGeometry = createLensedArc(outerDiskRadius * 0.9, -shadowRadius * 1.5, 64);
            const undersideMaterial = new THREE.LineBasicMaterial({
                color: 0xff4400,
                transparent: true,
                opacity: 0.5,
                linewidth: 2
            });
            const underside = new THREE.Line(undersideGeometry, undersideMaterial);
            underside.rotation.x = -Math.PI / 2;
            group.add(underside);
            
            // Create lensed disk sections using curved planes
            function createLensedDiskSection(radius, height, segments = 32) {
                const geometry = new THREE.PlaneGeometry(radius * 2, radius * 0.3, segments, 4);
                const positions = geometry.attributes.position;
                
                // Curve the plane to show gravitational lensing
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const curve = Math.sin((x / radius + 1) * Math.PI) * height;
                    positions.setY(i, y + curve);
                }
                positions.needsUpdate = true;
                geometry.computeVertexNormals();
                return geometry;
            }
            
            // Far side lensed disk (above main disk)
            const farSideDiskGeometry = createLensedDiskSection(outerDiskRadius, shadowRadius * 1.2, 32);
            const farSideDiskMaterial = new THREE.MeshBasicMaterial({
                color: 0xff5500,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.4,
                emissive: 0xff3300,
                emissiveIntensity: 0.5
            });
            const farSideDisk = new THREE.Mesh(farSideDiskGeometry, farSideDiskMaterial);
            farSideDisk.rotation.x = -Math.PI / 2 + 0.3; // Tilted upward
            farSideDisk.position.y = shadowRadius * 0.8;
            group.add(farSideDisk);
            
            // Underside lensed disk (below main disk)
            const undersideDiskGeometry = createLensedDiskSection(outerDiskRadius, -shadowRadius * 1.2, 32);
            const undersideDiskMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4400,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.35,
                emissive: 0xff2200,
                emissiveIntensity: 0.4
            });
            const undersideDisk = new THREE.Mesh(undersideDiskGeometry, undersideDiskMaterial);
            undersideDisk.rotation.x = -Math.PI / 2 - 0.3; // Tilted downward
            undersideDisk.position.y = -shadowRadius * 0.8;
            group.add(undersideDisk);
            
            // Store rotation speed for animation
            group.userData.rotationSpeed = 0.02;
            group.userData.diskObjects = [innerDisk, outerDisk, photonRing, farSideDisk, undersideDisk];
            
            return group;
        }

        function createWhiteHole(data) {
            const group = new THREE.Group();
            group.userData = { ...data, type: 'whiteHole' };
            
            // White hole - opposite of black hole, emits light and matter
            // Create bright white glowing sphere with outward-flowing particles
            const whiteHoleGeometry = new THREE.SphereGeometry(data.size, 32, 32);
            const whiteHoleMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 2.0,
                transparent: true,
                opacity: 0.9
            });
            const whiteHole = new THREE.Mesh(whiteHoleGeometry, whiteHoleMaterial);
            group.add(whiteHole);
            
            // Outer glow - bright white halo
            const glowGeometry = new THREE.SphereGeometry(data.size * 1.5, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 1.5,
                transparent: true,
                opacity: 0.6,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            group.add(glow);
            
            // Outward-flowing accretion disk (opposite of black hole)
            const innerDiskRadius = data.size * 1.3;
            const midDiskRadius = data.size * 2.0;
            const outerDiskRadius = data.size * 3.5;
            
            // Inner hot disk (white/blue)
            const innerDiskGeometry = new THREE.RingGeometry(innerDiskRadius, midDiskRadius, 128);
            const innerDiskMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.8,
                emissive: 0xffffff,
                emissiveIntensity: 1.2
            });
            const innerDisk = new THREE.Mesh(innerDiskGeometry, innerDiskMaterial);
            innerDisk.rotation.x = -Math.PI / 2;
            group.add(innerDisk);
            
            // Outer disk (blue-white)
            const outerDiskGeometry = new THREE.RingGeometry(midDiskRadius, outerDiskRadius, 128);
            const outerDiskMaterial = new THREE.MeshBasicMaterial({
                color: 0xaaccff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6,
                emissive: 0x88bbff,
                emissiveIntensity: 0.8
            });
            const outerDisk = new THREE.Mesh(outerDiskGeometry, outerDiskMaterial);
            outerDisk.rotation.x = -Math.PI / 2;
            group.add(outerDisk);
            
            // Store rotation speed for animation (opposite direction from black hole)
            group.userData.rotationSpeed = -0.02;
            group.userData.diskObjects = [innerDisk, outerDisk];
            
            return group;
        }

        // Initialize all objects
        function initializeObjects() {
            // Planets
            celestialData.planets.forEach(data => {
                const planet = createPlanet(data);
                
                // Add rings to Saturn
                if (data.name === 'Saturn') {
                    const rings = createSaturnRings(data.size);
                    planet.add(rings); // Add rings as child of planet so they rotate together
                    planet.userData.rings = rings;
                }
                
                // Add rings and cloud bands to Jupiter
                if (data.name === 'Jupiter') {
                    const rings = createJupiterRings(data.size);
                    planet.add(rings);
                    planet.userData.rings = rings;
                    const cloudBands = createJupiterCloudBands(data.size);
                    planet.add(cloudBands);
                    planet.userData.cloudBands = cloudBands;
                }
                
                // Add rings to Uranus
                if (data.name === 'Uranus') {
                    const rings = createUranusRings(data.size);
                    planet.add(rings);
                    planet.userData.rings = rings;
                }
                
                // Add rings to Neptune
                if (data.name === 'Neptune') {
                    const rings = createNeptuneRings(data.size);
                    planet.add(rings);
                    planet.userData.rings = rings;
                }
                
                // Add continents to Earth
                if (data.name === 'Earth') {
                    const continents = createEarthContinents(data.size);
                    planet.add(continents); // Add continents as child of planet so they rotate together
                    planet.userData.continents = continents;
                }
                
                allObjects[data.name] = planet;
                scene.add(planet);
                if (data.distance > 0) {
                    const orbit = createOrbit(data.distance);
                    orbitPaths[data.name] = orbit;
                    scene.add(orbit);
                }
            });

            // Dwarf planets
            celestialData.dwarfPlanets.forEach(data => {
                const planet = createPlanet(data);
                allObjects[data.name] = planet;
                scene.add(planet);
                const orbit = createOrbit(data.distance);
                orbitPaths[data.name] = orbit;
                scene.add(orbit);
            });

            // Moons
            celestialData.moons.forEach(data => {
                const parent = allObjects[data.parent];
                if (parent) {
                    const moon = createMoon(data, parent);
                    allObjects[data.name] = moon;
                    scene.add(moon);
                }
            });

            // Meteors
            celestialData.meteors.forEach(data => {
                const meteor = createMeteor(data);
                allObjects[data.name] = meteor;
                meteorObjects.push(meteor);
                scene.add(meteor);
            });

            // Asteroids
            celestialData.asteroids.forEach(data => {
                const asteroid = createAsteroid(data);
                allObjects[data.name] = asteroid;
                scene.add(asteroid);
                if (data.distance > 0) {
                    const orbit = createOrbit(data.distance);
                    orbitPaths[data.name] = orbit;
                    scene.add(orbit);
                }
            });

            // Comets
            celestialData.comets.forEach(data => {
                const comet = createComet(data);
                allObjects[data.name] = comet;
                scene.add(comet);
                scene.add(comet.userData.trail);
                cometTrails.push(comet);
            });

            // Exoplanets
            celestialData.exoplanets.forEach(data => {
                const planet = createPlanet(data);
                
                // Add rings to exoplanets that have them
                if (data.hasRings) {
                    if (data.name === 'J1407b') {
                        // J1407b has massive rings
                        const rings = createJ1407bRings(data.size);
                        planet.add(rings);
                        planet.userData.rings = rings;
                    } else {
                        // Other exoplanets get standard exoplanet rings
                        const ringColor = data.color || 0x6b8cff;
                        const rings = createExoplanetRings(data.size, ringColor);
                        planet.add(rings);
                        planet.userData.rings = rings;
                    }
                }
                
                allObjects[data.name] = planet;
                scene.add(planet);
                planet.userData.angle = Math.random() * Math.PI * 2;
                const orbit = createOrbit(data.distance);
                orbitPaths[data.name] = orbit;
                scene.add(orbit);
            });

            // Stars
            celestialData.stars.forEach(data => {
                const star = createPlanet(data);
                
                // Enhanced star materials with glow effect
                star.material.emissiveIntensity = 1.0;
                star.material.shininess = 100;
                
                // Position stars at their distance from origin
                if (data.distance > 0) {
                    // Position stars in a sphere around the origin
                    const angle = Math.random() * Math.PI * 2;
                    const elevation = (Math.random() - 0.5) * Math.PI * 0.5; // Slight elevation variation
                    star.position.x = Math.cos(elevation) * Math.cos(angle) * data.distance;
                    star.position.y = Math.sin(elevation) * data.distance * 0.3; // Slight vertical spread
                    star.position.z = Math.cos(elevation) * Math.sin(angle) * data.distance;
                    star.userData.initialPosition = star.position.clone();
                } else {
                    // Sun stays at origin
                    star.position.set(0, 0, 0);
                    star.userData.initialPosition = star.position.clone();
                }
                
                if (data.name === 'Sun') {
                    star.material.color = new THREE.Color(0xffaa00);
                    star.material.emissive = new THREE.Color(0xffaa00);
                    star.material.emissiveIntensity = 1.5;
                    // Add point light for Sun
                    sunLight.position.copy(star.position);
                    sunLight.intensity = 3;
                } else {
                    star.material.color = new THREE.Color(data.color);
                    star.material.emissive = new THREE.Color(data.color);
                    star.material.emissiveIntensity = 1.2;
                    
                    // Add glow effect for stars (larger outer sphere with transparency)
                    const glowGeometry = new THREE.SphereGeometry(data.size * 1.5, 16, 16);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: data.color,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.BackSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    star.add(glow);
                }
                
                allObjects[data.name] = star;
                scene.add(star);
            });

            // Galaxies
            celestialData.galaxies.forEach(data => {
                const galaxy = createGalaxy(data);
                galaxy.position.set(...(data.position || [1000, 0, 0]));
                allObjects[data.name] = galaxy;
                scene.add(galaxy);
            });

            // Protoplanets
            celestialData.protoplanets.forEach(data => {
                const planet = createPlanet(data);
                planet.material.emissiveIntensity = 0.3;
                allObjects[data.name] = planet;
                scene.add(planet);
                planet.userData.angle = Math.random() * Math.PI * 2;
                const orbit = createOrbit(data.distance);
                orbitPaths[data.name] = orbit;
                scene.add(orbit);
            });

            // Nebulas
            celestialData.nebulas.forEach(data => {
                const nebula = createNebula(data);
                nebula.position.set(...data.position);
                allObjects[data.name] = nebula;
                nebulaObjects.push(nebula);
                scene.add(nebula);
            });

            // Superclusters
            celestialData.superclusters.forEach(data => {
                const supercluster = createSupercluster(data);
                supercluster.position.set(...data.position);
                allObjects[data.name] = supercluster;
                scene.add(supercluster);
            });

            // Black Holes
            celestialData.blackHoles.forEach(data => {
                const blackHole = createBlackHole(data);
                // Position black holes at their distance from origin (similar to stars)
                if (data.distance > 0) {
                    const angle = Math.random() * Math.PI * 2;
                    const elevation = (Math.random() - 0.5) * Math.PI * 0.5;
                    blackHole.position.x = Math.cos(elevation) * Math.cos(angle) * data.distance;
                    blackHole.position.y = Math.sin(elevation) * data.distance * 0.3;
                    blackHole.position.z = Math.cos(elevation) * Math.sin(angle) * data.distance;
                    blackHole.userData.initialPosition = blackHole.position.clone();
                } else {
                    blackHole.position.set(0, 0, 0);
                    blackHole.userData.initialPosition = blackHole.position.clone();
                }
                allObjects[data.name] = blackHole;
                scene.add(blackHole);
            });

            // White Holes
            celestialData.whiteHoles.forEach(data => {
                const whiteHole = createWhiteHole(data);
                // Position white holes at their distance from origin (similar to stars)
                if (data.distance > 0) {
                    const angle = Math.random() * Math.PI * 2;
                    const elevation = (Math.random() - 0.5) * Math.PI * 0.5;
                    whiteHole.position.x = Math.cos(elevation) * Math.cos(angle) * data.distance;
                    whiteHole.position.y = Math.sin(elevation) * data.distance * 0.3;
                    whiteHole.position.z = Math.cos(elevation) * Math.sin(angle) * data.distance;
                    whiteHole.userData.initialPosition = whiteHole.position.clone();
                } else {
                    whiteHole.position.set(0, 0, 0);
                    whiteHole.userData.initialPosition = whiteHole.position.clone();
                }
                allObjects[data.name] = whiteHole;
                scene.add(whiteHole);
            });
        }

        function createOrbit(distance) {
            const orbitGeometry = new THREE.RingGeometry(distance - 0.1, distance + 0.1, 128);
            const orbitMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.2
            });
            const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbit.rotation.x = -Math.PI / 2;
            return orbit;
        }

        // UI Controls
        const categorySelect = document.getElementById('categorySelect');
        const objectSelect = document.getElementById('objectSelect');
        let currentCategory = 'planets';
        let currentObject = null;
        let animationSpeed = 0.5;
        let isAnimating = true;

        function updateObjectSelect(skipAutoSelect = false) {
            objectSelect.innerHTML = '';
            const category = categorySelect.value;
            currentCategory = category;
            const objects = celestialData[category] || [];
            
            objects.forEach(obj => {
                const option = document.createElement('option');
                option.value = obj.name;
                option.textContent = obj.name;
                objectSelect.appendChild(option);
            });
            
            if (objects.length > 0 && !skipAutoSelect) {
                selectObject(objects[0].name);
            }
        }

        function selectObject(objectName) {
            const obj = allObjects[objectName];
            if (!obj) return;
            
            currentObject = obj;
            const data = celestialData[currentCategory].find(o => o.name === objectName);
            
            // Update info
            document.getElementById('objectName').textContent = objectName;
            const description = data?.desc || 'Celestial object';
            // Check if description contains HTML (for stars explanation)
            if (description.includes('<strong>') || description.includes('<br>')) {
                document.getElementById('objectDescription').innerHTML = description;
            } else {
                document.getElementById('objectDescription').textContent = description;
            }
            document.getElementById('objectInfo').style.display = 'block';
            
            // Special handling for Sun - show educational info
            if (objectName === 'Sun') {
                document.getElementById('objectDescription').innerHTML = 
                    '<strong>G-type Main Sequence Star (Yellow Dwarf)</strong><br><br>' +
                    'The Sun is a star just like all the other stars in the sky! ' +
                    'The only difference is that it\'s much closer to us (93 million miles away). ' +
                    'Other stars are so far away they appear as tiny points of light.<br><br>' +
                    '<strong>Why is the Sun a star?</strong><br>' +
                    'All stars, including the Sun, are massive balls of hot gas that produce light and heat through nuclear fusion. ' +
                    'The Sun fuses hydrogen into helium in its core, releasing enormous amounts of energy. ' +
                    'This is what makes it shine and provides light and heat to Earth.';
            }
            
            // Focus camera
            if (obj.userData.type === 'galaxy' || obj.userData.type === 'nebula' || obj.userData.type === 'supercluster') {
                camera.position.set(
                    obj.position.x + 50,
                    obj.position.y + 50,
                    obj.position.z + 50
                );
                controls.target.copy(obj.position);
                controls.minDistance = 10;
                controls.maxDistance = 1000;
            } else {
                // For stars and other objects, use their actual position
                const objSize = obj.userData.size || 1;
                const viewDistance = Math.max(objSize * 3, 5); // At least 3x the size, minimum 5 units
                
                // Calculate camera position relative to object
                const direction = new THREE.Vector3(1, 0.5, 1).normalize();
                camera.position.set(
                    obj.position.x + direction.x * viewDistance,
                    obj.position.y + direction.y * viewDistance,
                    obj.position.z + direction.z * viewDistance
                );
                controls.target.copy(obj.position);
                controls.minDistance = objSize * 0.5;
                controls.maxDistance = Math.max(obj.userData.distance * 2, 1000);
            }
            controls.update();
        }

        categorySelect.addEventListener('change', updateObjectSelect);
        objectSelect.addEventListener('change', (e) => selectObject(e.target.value));

        document.getElementById('speedSlider').addEventListener('input', (e) => {
            animationSpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = animationSpeed.toFixed(1) + 'x';
        });

        document.getElementById('orbitSlider').addEventListener('input', (e) => {
            const opacity = parseFloat(e.target.value);
            Object.values(orbitPaths).forEach(orbit => {
                orbit.material.opacity = opacity * 0.2;
            });
            cometTrails.forEach(comet => {
                if (comet.userData.trail) {
                    comet.userData.trail.material.opacity = opacity * 0.5;
                }
            });
            document.getElementById('orbitValue').textContent = Math.round(opacity * 100) + '%';
        });

        document.getElementById('resetCamera').addEventListener('click', () => {
            if (currentObject) {
                selectObject(currentObject.userData.name);
            }
        });

        document.getElementById('toggleAnimation').addEventListener('click', (e) => {
            isAnimating = !isAnimating;
            e.target.textContent = isAnimating ? 'Pause' : 'Play';
        });

        document.getElementById('showAllStars').addEventListener('click', () => {
            // Switch to stars category
            categorySelect.value = 'stars';
            updateObjectSelect();
            
            // Position camera to see all stars
            camera.position.set(0, 0, 1000);
            controls.target.set(0, 0, 0);
            controls.minDistance = 100;
            controls.maxDistance = 50000;
            controls.update();
            
            // Show info about stars
            document.getElementById('objectName').textContent = 'All Stars View';
            document.getElementById('objectDescription').innerHTML = 
                '<strong>Why is the Sun a star?</strong><br>' +
                'The Sun is a G-type main sequence star (yellow dwarf). It\'s a star just like all the others in the sky! ' +
                'The only difference is that it\'s much closer to us (93 million miles away). ' +
                'Other stars are so far away they appear as tiny points of light. ' +
                'All stars are massive balls of hot gas that produce light and heat through nuclear fusion.';
            document.getElementById('objectInfo').style.display = 'block';
        });

        // Click to focus
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        renderer.domElement.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const allSceneObjects = Object.values(allObjects);
            const intersects = raycaster.intersectObjects(allSceneObjects, true);
            if (intersects.length > 0) {
                let clickedObj = intersects[0].object;
                while (clickedObj.parent && clickedObj.parent !== scene) {
                    clickedObj = clickedObj.parent;
                }
                if (clickedObj.userData && clickedObj.userData.name) {
                    // Find which category it belongs to
                    for (const [category, objects] of Object.entries(celestialData)) {
                        if (objects.find(o => o.name === clickedObj.userData.name)) {
                            categorySelect.value = category;
                            updateObjectSelect(true); // Skip auto-select to avoid selecting first object
                            objectSelect.value = clickedObj.userData.name;
                            selectObject(clickedObj.userData.name);
                            break;
                        }
                    }
                }
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (isAnimating) {
                // Animate planets and dwarf planets
                [...celestialData.planets, ...celestialData.dwarfPlanets, ...celestialData.exoplanets, ...celestialData.protoplanets].forEach(data => {
                    const obj = allObjects[data.name];
                    if (obj && obj.userData.distance > 0) {
                        obj.userData.angle += obj.userData.speed * animationSpeed;
                        obj.position.x = Math.cos(obj.userData.angle) * obj.userData.distance;
                        obj.position.z = Math.sin(obj.userData.angle) * obj.userData.distance;
                        obj.rotation.y += 0.03 * animationSpeed;
                    }
                });

                // Animate asteroids
                celestialData.asteroids.forEach(data => {
                    const asteroid = allObjects[data.name];
                    if (asteroid && asteroid.userData.distance > 0) {
                        asteroid.userData.angle += asteroid.userData.speed * animationSpeed;
                        asteroid.position.x = Math.cos(asteroid.userData.angle) * asteroid.userData.distance;
                        asteroid.position.z = Math.sin(asteroid.userData.angle) * asteroid.userData.distance;
                        asteroid.rotation.x += 0.05 * animationSpeed;
                        asteroid.rotation.y += 0.04 * animationSpeed;
                        asteroid.rotation.z += 0.03 * animationSpeed;
                    }
                });

                // Animate moons
                celestialData.moons.forEach(data => {
                    const moon = allObjects[data.name];
                    const parent = allObjects[data.parent];
                    if (moon && parent) {
                        moon.userData.angle += moon.userData.speed * animationSpeed;
                        const offsetX = Math.cos(moon.userData.angle) * moon.userData.distance;
                        const offsetZ = Math.sin(moon.userData.angle) * moon.userData.distance;
                        moon.position.set(
                            parent.position.x + offsetX,
                            parent.position.y,
                            parent.position.z + offsetZ
                        );
                        moon.rotation.y += 0.06 * animationSpeed;
                    }
                });

                // Animate comets
                cometTrails.forEach(comet => {
                    if (comet.userData.distance) {
                        comet.userData.angle += comet.userData.speed * animationSpeed;
                        const eccentricity = comet.userData.eccentricity || 0.7;
                        const a = comet.userData.distance / (1 - eccentricity);
                        const r = a * (1 - eccentricity * eccentricity) / (1 + eccentricity * Math.cos(comet.userData.angle));
                        comet.position.x = Math.cos(comet.userData.angle) * r;
                        comet.position.z = Math.sin(comet.userData.angle) * r;
                        
                        // Update trail
                        comet.userData.trail.userData.points.push(comet.position.clone());
                        if (comet.userData.trail.userData.points.length > 50) {
                            comet.userData.trail.userData.points.shift();
                        }
                        if (comet.userData.trail.userData.points.length > 1) {
                            const points = comet.userData.trail.userData.points.map(p => [p.x, p.y, p.z]).flat();
                            comet.userData.trail.geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                        }
                    }
                });

                // Animate meteors
                meteorObjects.forEach(meteor => {
                    meteor.position.add(meteor.userData.velocity.clone().multiplyScalar(animationSpeed));
                    meteor.rotation.x += 0.3 * animationSpeed;
                    meteor.rotation.y += 0.3 * animationSpeed;
                    
                    // Reset if too far
                    if (meteor.position.length() > 200) {
                        meteor.position.set(
                            (Math.random() - 0.5) * 50,
                            (Math.random() - 0.5) * 50,
                            (Math.random() - 0.5) * 50
                        );
                    }
                });

                // Rotate Sun
                const sun = allObjects['Sun'];
                if (sun) {
                    sun.rotation.y += 0.015 * animationSpeed;
                }

                // Rotate nebulas
                nebulaObjects.forEach(nebula => {
                    nebula.rotation.y += 0.003 * animationSpeed;
                });

                // Rotate black hole accretion disks
                celestialData.blackHoles.forEach(data => {
                    const blackHole = allObjects[data.name];
                    if (blackHole && blackHole.userData.rotationSpeed && blackHole.userData.diskObjects) {
                        // Rotate all accretion disk objects around the Y axis (spinning effect)
                        // Different layers rotate at slightly different speeds for realism
                        blackHole.userData.diskObjects.forEach((disk, index) => {
                            // Inner disks rotate faster than outer disks
                            const speedMultiplier = 1.0 - (index * 0.08);
                            disk.rotation.y += blackHole.userData.rotationSpeed * animationSpeed * speedMultiplier;
                        });
                    }
                });

                // Rotate white hole accretion disks (opposite direction)
                celestialData.whiteHoles.forEach(data => {
                    const whiteHole = allObjects[data.name];
                    if (whiteHole && whiteHole.userData.rotationSpeed && whiteHole.userData.diskObjects) {
                        // Rotate all accretion disk objects around the Y axis (spinning effect, opposite direction)
                        whiteHole.userData.diskObjects.forEach((disk, index) => {
                            // Inner disks rotate faster than outer disks
                            const speedMultiplier = 1.0 - (index * 0.08);
                            disk.rotation.y += whiteHole.userData.rotationSpeed * animationSpeed * speedMultiplier;
                        });
                    }
                });
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        initializeObjects();
        updateObjectSelect();

        // Hide loading screen
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
        }, 1000);

        // Start animation
        animate();
    </script>
</body>
</html>